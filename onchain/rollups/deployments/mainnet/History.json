{
  "address": "0x07D4FBc22FBB7342428C7B24614Ab47b8C44B18f",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "InvalidClaimIndex",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidInputIndices",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnclaimedInputs",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "dapp",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "epochHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint128",
              "name": "firstIndex",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "lastIndex",
              "type": "uint128"
            }
          ],
          "indexed": false,
          "internalType": "struct History.Claim",
          "name": "claim",
          "type": "tuple"
        }
      ],
      "name": "NewClaimToHistory",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_dapp",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_proofContext",
          "type": "bytes"
        }
      ],
      "name": "getClaim",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_consensus",
          "type": "address"
        }
      ],
      "name": "migrateToConsensus",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_claimData",
          "type": "bytes"
        }
      ],
      "name": "submitClaim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xae5a4f0a91675795b088e91ed371cd64569e5f9245aa71f579c025739a1d7df5",
  "receipt": {
    "to": "0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7",
    "from": "0x0e28A8f88C6266dF0FE274c15c1d4b27f8B373C0",
    "contractAddress": null,
    "transactionIndex": 132,
    "gasUsed": "494590",
    "logsBloom": "0x00000400000000000000000000000000000000000008000000800000000000000000000000000000000000000800000008000000000000000000000000000000000000000020000000000000000000000001000000000000000000000000000000000080020000000000000000000800000000800000000000000000000000400000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9d7f83d21041f070f17ae2902aef0c067b5c25429d6bdc4e271e58d842213c71",
    "transactionHash": "0xae5a4f0a91675795b088e91ed371cd64569e5f9245aa71f579c025739a1d7df5",
    "logs": [
      {
        "transactionIndex": 132,
        "blockNumber": 17784742,
        "transactionHash": "0xae5a4f0a91675795b088e91ed371cd64569e5f9245aa71f579c025739a1d7df5",
        "address": "0x07D4FBc22FBB7342428C7B24614Ab47b8C44B18f",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000914d7fec6aac8cd542e72bca78b30650d45643d7"
        ],
        "data": "0x",
        "logIndex": 296,
        "blockHash": "0x9d7f83d21041f070f17ae2902aef0c067b5c25429d6bdc4e271e58d842213c71"
      },
      {
        "transactionIndex": 132,
        "blockNumber": 17784742,
        "transactionHash": "0xae5a4f0a91675795b088e91ed371cd64569e5f9245aa71f579c025739a1d7df5",
        "address": "0x07D4FBc22FBB7342428C7B24614Ab47b8C44B18f",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x000000000000000000000000914d7fec6aac8cd542e72bca78b30650d45643d7",
          "0x0000000000000000000000008ae74caffda680de61a8af34e2c9e8d11079fd9a"
        ],
        "data": "0x",
        "logIndex": 297,
        "blockHash": "0x9d7f83d21041f070f17ae2902aef0c067b5c25429d6bdc4e271e58d842213c71"
      }
    ],
    "blockNumber": 17784742,
    "cumulativeGasUsed": "12120985",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x8Ae74CAfFda680dE61a8Af34E2C9E8D11079fd9a"
  ],
  "numDeployments": 1,
  "solcInputHash": "d2696284402b6703b2d41170c93ef3b7",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidClaimIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInputIndices\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnclaimedInputs\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dapp\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"epochHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"firstIndex\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lastIndex\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"struct History.Claim\",\"name\":\"claim\",\"type\":\"tuple\"}],\"name\":\"NewClaimToHistory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dapp\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_proofContext\",\"type\":\"bytes\"}],\"name\":\"getClaim\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_consensus\",\"type\":\"address\"}],\"name\":\"migrateToConsensus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_claimData\",\"type\":\"bytes\"}],\"name\":\"submitClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This contract inherits OpenZeppelin's `Ownable` contract.      For more information on `Ownable`, please consult OpenZeppelin's official documentation.\",\"events\":{\"NewClaimToHistory(address,(bytes32,uint128,uint128))\":{\"details\":\"MUST be triggered on a successful call to `submitClaim`.\",\"params\":{\"claim\":\"The newly-submitted claim\",\"dapp\":\"The address of the DApp\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_owner\":\"The initial owner\"}},\"getClaim(address,bytes)\":{\"details\":\"If `claimIndex` is not inside the interval `[0, n)`, then      an `InvalidClaimIndex` error is raised.\",\"params\":{\"_dapp\":\"The DApp address\",\"_proofContext\":\"Data for retrieving the desired claim\"},\"returns\":{\"_0\":\"The claimed epoch hash\",\"_1\":\"The index of the first input of the epoch in the input box\",\"_2\":\"The index of the last input of the epoch in the input box\"}},\"migrateToConsensus(address)\":{\"details\":\"Emits an `OwnershipTransferred` event. Should have access control.\",\"params\":{\"_consensus\":\"The new consensus\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"submitClaim(bytes)\":{\"details\":\"Emits a `NewClaimToHistory` event. Should have access control.      Incorrect claim input indices could raise two errors:      `InvalidInputIndices` if first index is posterior than last index or      `UnclaimedInputs` if first index is not the subsequent of previous claimed index or                        if the first index of the first claim is not zero.\",\"params\":{\"_claimData\":\"Data for submitting a claim\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"stateVariables\":{\"claims\":{\"details\":\"See the `getClaim` and `submitClaim` functions.\"}},\"title\":\"Simple History\",\"version\":1},\"userdoc\":{\"errors\":{\"InvalidClaimIndex()\":[{\"notice\":\"Raised when one tries to retrieve a claim with an invalid index.\"}],\"InvalidInputIndices()\":[{\"notice\":\"Raised when one tries to submit a claim whose first input index         is not less than or equal to its last input index.\"}],\"UnclaimedInputs()\":[{\"notice\":\"Raised when one tries to submit a claim that skips some input.         For example, when the 1st claim starts at index 5 (instead of 0)         or when the 1st claim ends at index 20 but the 2nd claim starts at         index 22 (instead of 21).\"}]},\"events\":{\"NewClaimToHistory(address,(bytes32,uint128,uint128))\":{\"notice\":\"A new claim regarding a specific DApp was submitted.\"}},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Creates a `History` contract.\"},\"getClaim(address,bytes)\":{\"notice\":\"Get a specific claim regarding a specific DApp. There are several requirements for this function to be called successfully. * `_proofContext` MUST be well-encoded. In Solidity, it can be constructed   as `abi.encode(claimIndex)`, where `claimIndex` is the claim index (type `uint256`). * `claimIndex` MUST be inside the interval `[0, n)` where `n` is the number of claims   that have been submitted to `_dapp` already.\"},\"migrateToConsensus(address)\":{\"notice\":\"Transfer ownership to another consensus.\"},\"submitClaim(bytes)\":{\"notice\":\"Submit a claim regarding a DApp. There are several requirements for this function to be called successfully. * `_claimData` MUST be well-encoded. In Solidity, it can be constructed   as `abi.encode(dapp, claim)`, where `dapp` is the DApp address (type `address`)   and `claim` is the claim structure (type `Claim`). * `firstIndex` MUST be less than or equal to `lastIndex`.   As a result, every claim MUST encompass AT LEAST one input. * If this is the DApp's first claim, then `firstIndex` MUST be `0`.   Otherwise, `firstIndex` MUST be the `lastClaim.lastIndex + 1`.   In other words, claims MUST NOT skip inputs.\"}},\"notice\":\"This contract stores claims for each DApp individually. This means that, for each DApp, the contract stores an array of `Claim` entries, where each `Claim` is composed of: * An epoch hash (`bytes32`) * A closed interval of input indices (`uint128`, `uint128`) The contract guarantees that the first interval starts at index 0, and that the following intervals don't have gaps or overlaps. Furthermore, claims can only be submitted by the contract owner through `submitClaim`, but can be retrieved by anyone with `getClaim`.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/history/History.sol\":\"History\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/history/History.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport {IHistory} from \\\"./IHistory.sol\\\";\\n\\n/// @title Simple History\\n///\\n/// @notice This contract stores claims for each DApp individually.\\n/// This means that, for each DApp, the contract stores an array of\\n/// `Claim` entries, where each `Claim` is composed of:\\n///\\n/// * An epoch hash (`bytes32`)\\n/// * A closed interval of input indices (`uint128`, `uint128`)\\n///\\n/// The contract guarantees that the first interval starts at index 0,\\n/// and that the following intervals don't have gaps or overlaps.\\n///\\n/// Furthermore, claims can only be submitted by the contract owner\\n/// through `submitClaim`, but can be retrieved by anyone with `getClaim`.\\n///\\n/// @dev This contract inherits OpenZeppelin's `Ownable` contract.\\n///      For more information on `Ownable`, please consult OpenZeppelin's official documentation.\\ncontract History is IHistory, Ownable {\\n    struct Claim {\\n        bytes32 epochHash;\\n        uint128 firstIndex;\\n        uint128 lastIndex;\\n    }\\n\\n    /// @notice Mapping from DApp address to number of claims.\\n    mapping(address => uint256) internal numClaims;\\n\\n    /// @notice Mapping from DApp address and claim index to claim.\\n    /// @dev See the `getClaim` and `submitClaim` functions.\\n    mapping(address => mapping(uint256 => Claim)) internal claims;\\n\\n    /// @notice A new claim regarding a specific DApp was submitted.\\n    /// @param dapp The address of the DApp\\n    /// @param claim The newly-submitted claim\\n    /// @dev MUST be triggered on a successful call to `submitClaim`.\\n    event NewClaimToHistory(address indexed dapp, Claim claim);\\n\\n    /// @notice Raised when one tries to submit a claim whose first input index\\n    ///         is not less than or equal to its last input index.\\n    error InvalidInputIndices();\\n\\n    /// @notice Raised when one tries to submit a claim that skips some input.\\n    ///         For example, when the 1st claim starts at index 5 (instead of 0)\\n    ///         or when the 1st claim ends at index 20 but the 2nd claim starts at\\n    ///         index 22 (instead of 21).\\n    error UnclaimedInputs();\\n\\n    /// @notice Raised when one tries to retrieve a claim with an invalid index.\\n    error InvalidClaimIndex();\\n\\n    /// @notice Creates a `History` contract.\\n    /// @param _owner The initial owner\\n    constructor(address _owner) {\\n        // constructor in Ownable already called `transferOwnership(msg.sender)`, so\\n        // we only need to call `transferOwnership(_owner)` if _owner != msg.sender\\n        if (_owner != msg.sender) {\\n            transferOwnership(_owner);\\n        }\\n    }\\n\\n    /// @notice Submit a claim regarding a DApp.\\n    /// There are several requirements for this function to be called successfully.\\n    ///\\n    /// * `_claimData` MUST be well-encoded. In Solidity, it can be constructed\\n    ///   as `abi.encode(dapp, claim)`, where `dapp` is the DApp address (type `address`)\\n    ///   and `claim` is the claim structure (type `Claim`).\\n    ///\\n    /// * `firstIndex` MUST be less than or equal to `lastIndex`.\\n    ///   As a result, every claim MUST encompass AT LEAST one input.\\n    ///\\n    /// * If this is the DApp's first claim, then `firstIndex` MUST be `0`.\\n    ///   Otherwise, `firstIndex` MUST be the `lastClaim.lastIndex + 1`.\\n    ///   In other words, claims MUST NOT skip inputs.\\n    ///\\n    /// @inheritdoc IHistory\\n    /// @dev Emits a `NewClaimToHistory` event. Should have access control.\\n    ///      Incorrect claim input indices could raise two errors:\\n    ///      `InvalidInputIndices` if first index is posterior than last index or\\n    ///      `UnclaimedInputs` if first index is not the subsequent of previous claimed index or\\n    ///                        if the first index of the first claim is not zero.\\n    function submitClaim(\\n        bytes calldata _claimData\\n    ) external override onlyOwner {\\n        (address dapp, Claim memory claim) = abi.decode(\\n            _claimData,\\n            (address, Claim)\\n        );\\n\\n        if (claim.firstIndex > claim.lastIndex) {\\n            revert InvalidInputIndices();\\n        }\\n\\n        uint256 numDAppClaims = numClaims[dapp];\\n\\n        if (\\n            claim.firstIndex !=\\n            (\\n                (numDAppClaims == 0)\\n                    ? 0\\n                    : (claims[dapp][numDAppClaims - 1].lastIndex + 1)\\n            )\\n        ) {\\n            revert UnclaimedInputs();\\n        }\\n\\n        claims[dapp][numDAppClaims] = claim;\\n        numClaims[dapp] = numDAppClaims + 1;\\n\\n        emit NewClaimToHistory(dapp, claim);\\n    }\\n\\n    /// @notice Get a specific claim regarding a specific DApp.\\n    /// There are several requirements for this function to be called successfully.\\n    ///\\n    /// * `_proofContext` MUST be well-encoded. In Solidity, it can be constructed\\n    ///   as `abi.encode(claimIndex)`, where `claimIndex` is the claim index (type `uint256`).\\n    ///\\n    /// * `claimIndex` MUST be inside the interval `[0, n)` where `n` is the number of claims\\n    ///   that have been submitted to `_dapp` already.\\n    ///\\n    /// @inheritdoc IHistory\\n    /// @dev If `claimIndex` is not inside the interval `[0, n)`, then\\n    ///      an `InvalidClaimIndex` error is raised.\\n    function getClaim(\\n        address _dapp,\\n        bytes calldata _proofContext\\n    ) external view override returns (bytes32, uint256, uint256) {\\n        uint256 claimIndex = abi.decode(_proofContext, (uint256));\\n\\n        uint256 numDAppClaims = numClaims[_dapp];\\n\\n        if (claimIndex >= numDAppClaims) {\\n            revert InvalidClaimIndex();\\n        }\\n\\n        Claim memory claim = claims[_dapp][claimIndex];\\n\\n        return (claim.epochHash, claim.firstIndex, claim.lastIndex);\\n    }\\n\\n    /// @inheritdoc IHistory\\n    /// @dev Emits an `OwnershipTransferred` event. Should have access control.\\n    function migrateToConsensus(\\n        address _consensus\\n    ) external override onlyOwner {\\n        transferOwnership(_consensus);\\n    }\\n}\\n\",\"keccak256\":\"0x9fa2563961c1769c3bba2b6b27ec90eca8423dd7b5b5f47e3ef90451a31d66c8\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/history/IHistory.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\n/// @title History interface\\ninterface IHistory {\\n    // Permissioned functions\\n\\n    /// @notice Submit a claim.\\n    ///         The encoding of `_claimData` might vary\\n    ///         depending on the history implementation.\\n    /// @param _claimData Data for submitting a claim\\n    /// @dev Should have access control.\\n    function submitClaim(bytes calldata _claimData) external;\\n\\n    /// @notice Transfer ownership to another consensus.\\n    /// @param _consensus The new consensus\\n    /// @dev Should have access control.\\n    function migrateToConsensus(address _consensus) external;\\n\\n    // Permissionless functions\\n\\n    /// @notice Get a specific claim regarding a specific DApp.\\n    ///         The encoding of `_proofContext` might vary\\n    ///         depending on the history implementation.\\n    /// @param _dapp The DApp address\\n    /// @param _proofContext Data for retrieving the desired claim\\n    /// @return epochHash_ The claimed epoch hash\\n    /// @return firstInputIndex_ The index of the first input of the epoch in the input box\\n    /// @return lastInputIndex_ The index of the last input of the epoch in the input box\\n    function getClaim(\\n        address _dapp,\\n        bytes calldata _proofContext\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32 epochHash_,\\n            uint256 firstInputIndex_,\\n            uint256 lastInputIndex_\\n        );\\n}\\n\",\"keccak256\":\"0x1378cbc831833abae8e2a565b88899d6416ea1208aa9724bd4df28e74848ffcf\",\"license\":\"Apache-2.0 (see LICENSE)\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5060405161091e38038061091e83398101604081905261002f91610181565b61003833610057565b6001600160a01b038116331461005157610051816100a7565b506101b1565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6100af610125565b6001600160a01b0381166101195760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61012281610057565b50565b6000546001600160a01b0316331461017f5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610110565b565b60006020828403121561019357600080fd5b81516001600160a01b03811681146101aa57600080fd5b9392505050565b61075e806101c06000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c8063715018a6146100675780638da5cb5b14610071578063d79a824014610091578063ddfdfbb0146100bf578063f2fde38b146100d2578063fc411683146100e5575b600080fd5b61006f6100f8565b005b6000546040516001600160a01b0390911681526020015b60405180910390f35b6100a461009f366004610531565b61010c565b60408051938452602084019290925290820152606001610088565b61006f6100cd366004610586565b6101bf565b61006f6100e03660046105c8565b61039a565b61006f6100f33660046105c8565b610418565b610100610429565b61010a6000610483565b565b600080808061011d858701876105ec565b6001600160a01b038816600090815260016020526040902054909150808210610159576040516387332c0160e01b815260040160405180910390fd5b506001600160a01b0396909616600090815260026020908152604080832098835297815290879020875160608101895281548082526001909201546001600160801b03808216948301859052600160801b90910416980188905297909695509350505050565b6101c7610429565b6000806101d683850185610621565b9150915080604001516001600160801b031681602001516001600160801b031611156102155760405163123974fd60e01b815260040160405180910390fd5b6001600160a01b038216600090815260016020526040902054801561028e576001600160a01b0383166000908152600260205260408120906102586001846106d5565b815260200190815260200160002060010160109054906101000a90046001600160801b0316600161028991906106ee565b610291565b60005b6001600160801b031682602001516001600160801b0316146102c65760405163118b891b60e01b815260040160405180910390fd5b6001600160a01b03831660009081526002602090815260408083208484528252918290208451815590840151918401516001600160801b03908116600160801b0292169190911760019182015561031e908290610715565b6001600160a01b03841660008181526001602090815260409182902093909355805185518152858401516001600160801b03908116948201949094528582015190931690830152907fb71880d7a0c514d48c0296b2721b0a4f9641a45117960f2ca86b5b7873c4ab2f9060600160405180910390a25050505050565b6103a2610429565b6001600160a01b03811661040c5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61041581610483565b50565b610420610429565b6104158161039a565b6000546001600160a01b0316331461010a5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610403565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b038116811461041557600080fd5b60008083601f8401126104fa57600080fd5b50813567ffffffffffffffff81111561051257600080fd5b60208301915083602082850101111561052a57600080fd5b9250929050565b60008060006040848603121561054657600080fd5b8335610551816104d3565b9250602084013567ffffffffffffffff81111561056d57600080fd5b610579868287016104e8565b9497909650939450505050565b6000806020838503121561059957600080fd5b823567ffffffffffffffff8111156105b057600080fd5b6105bc858286016104e8565b90969095509350505050565b6000602082840312156105da57600080fd5b81356105e5816104d3565b9392505050565b6000602082840312156105fe57600080fd5b5035919050565b80356001600160801b038116811461061c57600080fd5b919050565b600080828403608081121561063557600080fd5b8335610640816104d3565b92506060601f198201121561065457600080fd5b506040516060810181811067ffffffffffffffff8211171561068657634e487b7160e01b600052604160045260246000fd5b80604052506020840135815261069e60408501610605565b60208201526106af60608501610605565b6040820152809150509250929050565b634e487b7160e01b600052601160045260246000fd5b818103818111156106e8576106e86106bf565b92915050565b6001600160801b0381811683821601908082111561070e5761070e6106bf565b5092915050565b808201808211156106e8576106e86106bf56fea2646970667358221220af04065c5d35d3460abc2711367000a2134970c84818233d66386f35794dfb5b64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100625760003560e01c8063715018a6146100675780638da5cb5b14610071578063d79a824014610091578063ddfdfbb0146100bf578063f2fde38b146100d2578063fc411683146100e5575b600080fd5b61006f6100f8565b005b6000546040516001600160a01b0390911681526020015b60405180910390f35b6100a461009f366004610531565b61010c565b60408051938452602084019290925290820152606001610088565b61006f6100cd366004610586565b6101bf565b61006f6100e03660046105c8565b61039a565b61006f6100f33660046105c8565b610418565b610100610429565b61010a6000610483565b565b600080808061011d858701876105ec565b6001600160a01b038816600090815260016020526040902054909150808210610159576040516387332c0160e01b815260040160405180910390fd5b506001600160a01b0396909616600090815260026020908152604080832098835297815290879020875160608101895281548082526001909201546001600160801b03808216948301859052600160801b90910416980188905297909695509350505050565b6101c7610429565b6000806101d683850185610621565b9150915080604001516001600160801b031681602001516001600160801b031611156102155760405163123974fd60e01b815260040160405180910390fd5b6001600160a01b038216600090815260016020526040902054801561028e576001600160a01b0383166000908152600260205260408120906102586001846106d5565b815260200190815260200160002060010160109054906101000a90046001600160801b0316600161028991906106ee565b610291565b60005b6001600160801b031682602001516001600160801b0316146102c65760405163118b891b60e01b815260040160405180910390fd5b6001600160a01b03831660009081526002602090815260408083208484528252918290208451815590840151918401516001600160801b03908116600160801b0292169190911760019182015561031e908290610715565b6001600160a01b03841660008181526001602090815260409182902093909355805185518152858401516001600160801b03908116948201949094528582015190931690830152907fb71880d7a0c514d48c0296b2721b0a4f9641a45117960f2ca86b5b7873c4ab2f9060600160405180910390a25050505050565b6103a2610429565b6001600160a01b03811661040c5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61041581610483565b50565b610420610429565b6104158161039a565b6000546001600160a01b0316331461010a5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610403565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b038116811461041557600080fd5b60008083601f8401126104fa57600080fd5b50813567ffffffffffffffff81111561051257600080fd5b60208301915083602082850101111561052a57600080fd5b9250929050565b60008060006040848603121561054657600080fd5b8335610551816104d3565b9250602084013567ffffffffffffffff81111561056d57600080fd5b610579868287016104e8565b9497909650939450505050565b6000806020838503121561059957600080fd5b823567ffffffffffffffff8111156105b057600080fd5b6105bc858286016104e8565b90969095509350505050565b6000602082840312156105da57600080fd5b81356105e5816104d3565b9392505050565b6000602082840312156105fe57600080fd5b5035919050565b80356001600160801b038116811461061c57600080fd5b919050565b600080828403608081121561063557600080fd5b8335610640816104d3565b92506060601f198201121561065457600080fd5b506040516060810181811067ffffffffffffffff8211171561068657634e487b7160e01b600052604160045260246000fd5b80604052506020840135815261069e60408501610605565b60208201526106af60608501610605565b6040820152809150509250929050565b634e487b7160e01b600052601160045260246000fd5b818103818111156106e8576106e86106bf565b92915050565b6001600160801b0381811683821601908082111561070e5761070e6106bf565b5092915050565b808201808211156106e8576106e86106bf56fea2646970667358221220af04065c5d35d3460abc2711367000a2134970c84818233d66386f35794dfb5b64736f6c63430008130033",
  "devdoc": {
    "details": "This contract inherits OpenZeppelin's `Ownable` contract.      For more information on `Ownable`, please consult OpenZeppelin's official documentation.",
    "events": {
      "NewClaimToHistory(address,(bytes32,uint128,uint128))": {
        "details": "MUST be triggered on a successful call to `submitClaim`.",
        "params": {
          "claim": "The newly-submitted claim",
          "dapp": "The address of the DApp"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_owner": "The initial owner"
        }
      },
      "getClaim(address,bytes)": {
        "details": "If `claimIndex` is not inside the interval `[0, n)`, then      an `InvalidClaimIndex` error is raised.",
        "params": {
          "_dapp": "The DApp address",
          "_proofContext": "Data for retrieving the desired claim"
        },
        "returns": {
          "_0": "The claimed epoch hash",
          "_1": "The index of the first input of the epoch in the input box",
          "_2": "The index of the last input of the epoch in the input box"
        }
      },
      "migrateToConsensus(address)": {
        "details": "Emits an `OwnershipTransferred` event. Should have access control.",
        "params": {
          "_consensus": "The new consensus"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "submitClaim(bytes)": {
        "details": "Emits a `NewClaimToHistory` event. Should have access control.      Incorrect claim input indices could raise two errors:      `InvalidInputIndices` if first index is posterior than last index or      `UnclaimedInputs` if first index is not the subsequent of previous claimed index or                        if the first index of the first claim is not zero.",
        "params": {
          "_claimData": "Data for submitting a claim"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "stateVariables": {
      "claims": {
        "details": "See the `getClaim` and `submitClaim` functions."
      }
    },
    "title": "Simple History",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "InvalidClaimIndex()": [
        {
          "notice": "Raised when one tries to retrieve a claim with an invalid index."
        }
      ],
      "InvalidInputIndices()": [
        {
          "notice": "Raised when one tries to submit a claim whose first input index         is not less than or equal to its last input index."
        }
      ],
      "UnclaimedInputs()": [
        {
          "notice": "Raised when one tries to submit a claim that skips some input.         For example, when the 1st claim starts at index 5 (instead of 0)         or when the 1st claim ends at index 20 but the 2nd claim starts at         index 22 (instead of 21)."
        }
      ]
    },
    "events": {
      "NewClaimToHistory(address,(bytes32,uint128,uint128))": {
        "notice": "A new claim regarding a specific DApp was submitted."
      }
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Creates a `History` contract."
      },
      "getClaim(address,bytes)": {
        "notice": "Get a specific claim regarding a specific DApp. There are several requirements for this function to be called successfully. * `_proofContext` MUST be well-encoded. In Solidity, it can be constructed   as `abi.encode(claimIndex)`, where `claimIndex` is the claim index (type `uint256`). * `claimIndex` MUST be inside the interval `[0, n)` where `n` is the number of claims   that have been submitted to `_dapp` already."
      },
      "migrateToConsensus(address)": {
        "notice": "Transfer ownership to another consensus."
      },
      "submitClaim(bytes)": {
        "notice": "Submit a claim regarding a DApp. There are several requirements for this function to be called successfully. * `_claimData` MUST be well-encoded. In Solidity, it can be constructed   as `abi.encode(dapp, claim)`, where `dapp` is the DApp address (type `address`)   and `claim` is the claim structure (type `Claim`). * `firstIndex` MUST be less than or equal to `lastIndex`.   As a result, every claim MUST encompass AT LEAST one input. * If this is the DApp's first claim, then `firstIndex` MUST be `0`.   Otherwise, `firstIndex` MUST be the `lastClaim.lastIndex + 1`.   In other words, claims MUST NOT skip inputs."
      }
    },
    "notice": "This contract stores claims for each DApp individually. This means that, for each DApp, the contract stores an array of `Claim` entries, where each `Claim` is composed of: * An epoch hash (`bytes32`) * A closed interval of input indices (`uint128`, `uint128`) The contract guarantees that the first interval starts at index 0, and that the following intervals don't have gaps or overlaps. Furthermore, claims can only be submitted by the contract owner through `submitClaim`, but can be retrieved by anyone with `getClaim`.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1155,
        "contract": "contracts/history/History.sol:History",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 3149,
        "contract": "contracts/history/History.sol:History",
        "label": "numClaims",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 3157,
        "contract": "contracts/history/History.sol:History",
        "label": "claims",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_struct(Claim)3144_storage))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_struct(Claim)3144_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => struct History.Claim))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_struct(Claim)3144_storage)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_struct(Claim)3144_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct History.Claim)",
        "numberOfBytes": "32",
        "value": "t_struct(Claim)3144_storage"
      },
      "t_struct(Claim)3144_storage": {
        "encoding": "inplace",
        "label": "struct History.Claim",
        "members": [
          {
            "astId": 3139,
            "contract": "contracts/history/History.sol:History",
            "label": "epochHash",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 3141,
            "contract": "contracts/history/History.sol:History",
            "label": "firstIndex",
            "offset": 0,
            "slot": "1",
            "type": "t_uint128"
          },
          {
            "astId": 3143,
            "contract": "contracts/history/History.sol:History",
            "label": "lastIndex",
            "offset": 16,
            "slot": "1",
            "type": "t_uint128"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}