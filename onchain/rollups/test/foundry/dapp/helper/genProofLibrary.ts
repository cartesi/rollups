import { BytesLike } from "@ethersproject/bytes";
import fs from "fs";
import response from "./finish_epoch_response.json";

interface OutputValidityProof {
    inputIndexWithinEpoch: number;
    outputIndexWithinInput: number;
    outputHashesRootHash: BytesLike;
    vouchersEpochRootHash: BytesLike;
    noticesEpochRootHash: BytesLike;
    machineStateHash: BytesLike;
    outputHashInOutputHashesSiblings: BytesLike[];
    outputHashesInEpochSiblings: BytesLike[];
}

function setupVoucherProof(positionIndex: number): OutputValidityProof {
    let v = response.proofs[positionIndex].validity;
    let outputHashInOutputHashesSiblingsRawData =
        v.outputHashInOutputHashesSiblings;
    let outputHashesInEpochSiblingsRawData = v.outputHashesInEpochSiblings;
    var outputHashInOutputHashesSiblings: BytesLike[] = [];
    var outputHashesInEpochSiblings: BytesLike[] = [];
    outputHashInOutputHashesSiblingsRawData.forEach((element: any) => {
        outputHashInOutputHashesSiblings.push(element.data);
    });
    outputHashesInEpochSiblingsRawData.forEach((element: any) => {
        outputHashesInEpochSiblings.push(element.data);
    });
    let voucherProof: OutputValidityProof = {
        inputIndexWithinEpoch: Number(v.inputIndexWithinEpoch),
        outputIndexWithinInput: Number(v.outputIndexWithinInput),
        outputHashesRootHash: v.outputHashesRootHash.data,
        vouchersEpochRootHash: v.vouchersEpochRootHash.data,
        noticesEpochRootHash: v.noticesEpochRootHash.data,
        machineStateHash: v.machineStateHash.data,
        outputHashInOutputHashesSiblings: outputHashInOutputHashesSiblings, // siblings should be bottom-up ordered (from the leaf to the root)
        outputHashesInEpochSiblings: outputHashesInEpochSiblings,
    };
    return voucherProof;
}

function setupNoticeProof(positionIndex: number): OutputValidityProof {
    let v = response.proofs[positionIndex].validity;
    let outputHashInOutputHashesSiblingsRawData =
        v.outputHashInOutputHashesSiblings;
    let outputHashesInEpochSiblingsRawData = v.outputHashesInEpochSiblings;
    var outputHashInOutputHashesSiblings: BytesLike[] = [];
    var outputHashesInEpochSiblings: BytesLike[] = [];
    outputHashInOutputHashesSiblingsRawData.forEach((element) => {
        outputHashInOutputHashesSiblings.push(element.data);
    });
    outputHashesInEpochSiblingsRawData.forEach((element) => {
        outputHashesInEpochSiblings.push(element.data);
    });
    let noticeProof: OutputValidityProof = {
        inputIndexWithinEpoch: Number(v.inputIndexWithinEpoch),
        outputIndexWithinInput: Number(v.outputIndexWithinInput),
        outputHashesRootHash: v.outputHashesRootHash.data,
        vouchersEpochRootHash: v.vouchersEpochRootHash.data,
        noticesEpochRootHash: v.noticesEpochRootHash.data,
        machineStateHash: v.machineStateHash.data,
        outputHashInOutputHashesSiblings: outputHashInOutputHashesSiblings,
        outputHashesInEpochSiblings: outputHashesInEpochSiblings,
    };
    return noticeProof;
}

function generateLibraryCode(
    noticeProofs: OutputValidityProof[],
    voucherProofs: OutputValidityProof[],
    libraryName: string
): string {
    let functionLines: string[] = [];

    noticeProofs.forEach((noticeProof, index) => {
        functionLines.push(generateFunctionCode(noticeProof, `getNotice${index}Proof`))
    });

    voucherProofs.forEach((voucherProof, index) => {
        functionLines.push(generateFunctionCode(voucherProof, `getVoucher${index}Proof`))
    });

    const lines: string[] = [
        "// SPDX-License-Identifier: UNLICENSED",
        "",
        "pragma solidity ^0.8.8;",
        "",
        "// THIS FILE WAS AUTOMATICALLY GENERATED BY `genProofLibrary.ts`.",
        "",
        'import {OutputValidityProof} from "contracts/library/LibOutputValidation.sol";',
        "",
        `library ${libraryName} {`,
        ...functionLines,
        "}",
        ""
    ];

    return lines.join("\n");
}

function generateFunctionCode(
    proof: OutputValidityProof,
    functionName: string
): string {
    const array1 = proof.outputHashInOutputHashesSiblings;
    const array2 = proof.outputHashesInEpochSiblings;

    const lines: string[] = [
        `    function ${functionName}() internal pure returns (OutputValidityProof memory) {`,
        `        uint256[${array1.length}] memory array1 = [${array1}];`,
        `        uint256[${array2.length}] memory array2 = [${array2}];`,
        `        bytes32[] memory outputHashInOutputHashesSiblings = new bytes32[](${array1.length});`,
        `        bytes32[] memory outputHashesInEpochSiblings = new bytes32[](${array2.length});`,
        `        for (uint256 i; i < ${array1.length}; ++i) { outputHashInOutputHashesSiblings[i] = bytes32(array1[i]); }`,
        `        for (uint256 i; i < ${array2.length}; ++i) { outputHashesInEpochSiblings[i] = bytes32(array2[i]); }`,
        `        return OutputValidityProof({`,
        `            inputIndexWithinEpoch: ${proof.inputIndexWithinEpoch},`,
        `            outputIndexWithinInput: ${proof.outputIndexWithinInput},`,
        `            outputHashesRootHash: ${proof.outputHashesRootHash},`,
        `            vouchersEpochRootHash: ${proof.vouchersEpochRootHash},`,
        `            noticesEpochRootHash: ${proof.noticesEpochRootHash},`,
        `            machineStateHash: ${proof.machineStateHash},`,
        "            outputHashInOutputHashesSiblings: outputHashInOutputHashesSiblings,",
        "            outputHashesInEpochSiblings: outputHashesInEpochSiblings",
        "        });",
        "    }",
    ];

    return lines.join("\n");
}

const pairs = response.proofs.length / 2; // need to half because there's a voucher proof and notice proof for each input

// set up proofs
let voucherProofs: OutputValidityProof[] = new Array(pairs);
let noticeProofs: OutputValidityProof[] = new Array(pairs);
for (let i = 0; i < response.proofs.length; i++) {
    let inputIndex = Number(response.proofs[i].inputIndex);
    if (response.proofs[i].outputEnum == "NOTICE") {
        noticeProofs[inputIndex] = setupNoticeProof(i);
    } else {
        voucherProofs[inputIndex] = setupVoucherProof(i);
    }
}

// generate solidity library
const libraryName = "LibOutputProofs";
const solidityCode = generateLibraryCode(
    noticeProofs,
    voucherProofs,
    libraryName
);
const fileName = `${__dirname}/${libraryName}.sol`;
fs.writeFile(fileName, solidityCode, (err: any) => {
    if (err) throw err;
    console.log(`File '${fileName}' was generated.`);
});
